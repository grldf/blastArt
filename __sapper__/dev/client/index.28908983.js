import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, a as space, c as create_component, u as empty, y as query_selector_all, g as claim_element, j as detach_dev, f as claim_space, b as claim_component, k as attr_dev, l as add_location, o as append_dev, n as insert_dev, m as mount_component, t as transition_in, q as transition_out, r as destroy_component, w as validate_each_argument, z as text, h as children, A as claim_text, C as null_to_empty, D as set_data_dev, p as noop, x as destroy_each } from './client.f9495f84.js';
import { g as gql, D as DefaultClient } from './bundle.esm.ce987c6b.js';

/* src/routes/collectif/index.svelte generated by Svelte v3.35.0 */
const file = "src/routes/collectif/index.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	child_ctx[3] = i;
	return child_ctx;
}

// (76:2) {:else}
function create_else_block(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("FUCK");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, "FUCK");
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "test svelte-12psx4l");
			add_location(div, file, 76, 2, 2143);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(76:2) {:else}",
		ctx
	});

	return block;
}

// (57:2) {#if posts}
function create_if_block(ctx) {
	let div;
	let each_value = /*posts*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "content svelte-12psx4l");
			add_location(div, file, 57, 2, 1746);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*urlpApi, posts*/ 1) {
				each_value = /*posts*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(57:2) {#if posts}",
		ctx
	});

	return block;
}

// (59:2) {#each posts as post, i}
function create_each_block(ctx) {
	let div;
	let article;
	let h2;
	let t0_value = /*post*/ ctx[1].nom + "";
	let t0;
	let t1;
	let p;
	let t2_value = /*post*/ ctx[1].description + "";
	let t2;
	let t3;
	let aside;
	let img;
	let img_src_value;
	let img_alt_value;
	let t4;

	const block = {
		c: function create() {
			div = element("div");
			article = element("article");
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			p = element("p");
			t2 = text(t2_value);
			t3 = space();
			aside = element("aside");
			img = element("img");
			t4 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			article = claim_element(div_nodes, "ARTICLE", { class: true });
			var article_nodes = children(article);
			h2 = claim_element(article_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, t0_value);
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(article_nodes);
			p = claim_element(article_nodes, "P", { class: true });
			var p_nodes = children(p);
			t2 = claim_text(p_nodes, t2_value);
			p_nodes.forEach(detach_dev);
			article_nodes.forEach(detach_dev);
			t3 = claim_space(div_nodes);
			aside = claim_element(div_nodes, "ASIDE", { class: true });
			var aside_nodes = children(aside);
			img = claim_element(aside_nodes, "IMG", { src: true, alt: true, class: true });
			aside_nodes.forEach(detach_dev);
			t4 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "svelte-12psx4l");
			add_location(h2, file, 61, 8, 1868);
			attr_dev(p, "class", "svelte-12psx4l");
			add_location(p, file, 62, 8, 1896);
			attr_dev(article, "class", "svelte-12psx4l");
			add_location(article, file, 60, 6, 1850);
			if (img.src !== (img_src_value = urlpApi + /*post*/ ctx[1].profilimage.url)) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", img_alt_value = "portrait de " + /*post*/ ctx[1].nom);
			attr_dev(img, "class", "svelte-12psx4l");
			add_location(img, file, 67, 8, 1981);
			attr_dev(aside, "class", "svelte-12psx4l");
			add_location(aside, file, 66, 6, 1965);
			attr_dev(div, "class", "" + (null_to_empty(/*i*/ ctx[3] % 2 == 0 ? "impair" : "pair") + " svelte-12psx4l"));
			add_location(div, file, 59, 4, 1799);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, article);
			append_dev(article, h2);
			append_dev(h2, t0);
			append_dev(article, t1);
			append_dev(article, p);
			append_dev(p, t2);
			append_dev(div, t3);
			append_dev(div, aside);
			append_dev(aside, img);
			append_dev(div, t4);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*posts*/ 1 && t0_value !== (t0_value = /*post*/ ctx[1].nom + "")) set_data_dev(t0, t0_value);
			if (dirty & /*posts*/ 1 && t2_value !== (t2_value = /*post*/ ctx[1].description + "")) set_data_dev(t2, t2_value);

			if (dirty & /*posts*/ 1 && img.src !== (img_src_value = urlpApi + /*post*/ ctx[1].profilimage.url)) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*posts*/ 1 && img_alt_value !== (img_alt_value = "portrait de " + /*post*/ ctx[1].nom)) {
				attr_dev(img, "alt", img_alt_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(59:2) {#each posts as post, i}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let link;
	let t0;
	let svelteseo;
	let t1;
	let if_block_anchor;
	let current;

	svelteseo = new SvelteSeo({
			props: {
				description: "Présentaion des différents projets réalisés par le collectif Blastart, comme l'expositions unique le\n  terminal, le dinosaure Gustave de Romain Lardanchet et la fresque monumentale Gorilla urbaine réalisé par Kalouf. Ces \n  travaux sont rendus au travers des photos de FabeCollage et des vidéos de Jean-Pierre(staffvidéo)",
				title: "Projets réalisés par le collectif Blastart. Fresques, graphes sculptures les artistes relèvent tous les défis",
				openGraph: {
					type: "article",
					title: "Projets réalisés par le collectif Blastart",
					description: "Présentaion des différents projets réalisés par le collectif Blastart, comme l'expositions unique le terminal. ",
					url: "https://blast-art.art/blast",
					images: [
						{
							url: "https://blast-art.art/logo-512.png",
							width: 759,
							height: 585,
							alt: "Logo Blast art"
						}
					]
				}
			},
			$$inline: true
		});

	function select_block_type(ctx, dirty) {
		if (/*posts*/ ctx[0]) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			link = element("link");
			t0 = space();
			create_component(svelteseo.$$.fragment);
			t1 = space();
			if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1mne3ix\"]", document.head);
			link = claim_element(head_nodes, "LINK", { rel: true, href: true });
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			claim_component(svelteseo.$$.fragment, nodes);
			t1 = claim_space(nodes);
			if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(link, "rel", "stylesheet");
			attr_dev(link, "href", "https://use.typekit.net/ixn1cjn.css");
			add_location(link, file, 34, 4, 743);
		},
		m: function mount(target, anchor) {
			append_dev(document.head, link);
			insert_dev(target, t0, anchor);
			mount_component(svelteseo, target, anchor);
			insert_dev(target, t1, anchor);
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(svelteseo.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(svelteseo.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			detach_dev(link);
			if (detaching) detach_dev(t0);
			destroy_component(svelteseo, detaching);
			if (detaching) detach_dev(t1);
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const membreQuery = gql`
      query membre {
        collectifs(sort: "id:asc") {
          id
          nom
          description
          profilimage {
            url
          }
        }
      }
    `;

async function preload({ params, query }) {
	const client = new DefaultClient({
			uri: "https://www.grldfaure.xyz/graphql",
			fetch: this.fetch
		});

	const results = await client.query({ query: membreQuery });
	return { posts: results.data.collectifs };
}

let urlpApi = "https://grldfaure.xyz";

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Collectif", slots, []);
	let { posts } = $$props;
	const writable_props = ["posts"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Collectif> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("posts" in $$props) $$invalidate(0, posts = $$props.posts);
	};

	$$self.$capture_state = () => ({
		ApolloClient: DefaultClient,
		gql,
		membreQuery,
		preload,
		urlpApi,
		posts
	});

	$$self.$inject_state = $$props => {
		if ("posts" in $$props) $$invalidate(0, posts = $$props.posts);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [posts];
}

class Collectif extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { posts: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Collectif",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*posts*/ ctx[0] === undefined && !("posts" in props)) {
			console.warn("<Collectif> was created without expected prop 'posts'");
		}
	}

	get posts() {
		throw new Error("<Collectif>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set posts(value) {
		throw new Error("<Collectif>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Collectif;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguMjg5MDg5ODMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvY29sbGVjdGlmL2luZGV4LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cbiAgICBpbXBvcnQgQXBvbGxvQ2xpZW50LCB7IGdxbCB9IGZyb20gXCJhcG9sbG8tYm9vc3RcIjtcbiAgICBcbiAgICBjb25zdCBtZW1icmVRdWVyeSA9IGdxbGBcbiAgICAgIHF1ZXJ5IG1lbWJyZSB7XG4gICAgICAgIGNvbGxlY3RpZnMoc29ydDogXCJpZDphc2NcIikge1xuICAgICAgICAgIGlkXG4gICAgICAgICAgbm9tXG4gICAgICAgICAgZGVzY3JpcHRpb25cbiAgICAgICAgICBwcm9maWxpbWFnZSB7XG4gICAgICAgICAgICB1cmxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBgO1xuICAgIGV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVsb2FkKHsgcGFyYW1zLCBxdWVyeSB9KSB7XG4gICAgICBjb25zdCBjbGllbnQgPSBuZXcgQXBvbGxvQ2xpZW50KHtcbiAgICAgICAgdXJpOiBcImh0dHBzOi8vd3d3LmdybGRmYXVyZS54eXovZ3JhcGhxbFwiLFxuICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcblxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgY2xpZW50LnF1ZXJ5KHtcbiAgICAgICAgcXVlcnk6IG1lbWJyZVF1ZXJ5LFxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBwb3N0czogcmVzdWx0cy5kYXRhLmNvbGxlY3RpZnMgfTtcbiAgICB9XG4gICAgbGV0IHVybHBBcGkgPSBcImh0dHBzOi8vZ3JsZGZhdXJlLnh5elwiO1xuICA8L3NjcmlwdD5cbiAgXG4gIDxzY3JpcHQ+XG4gICAgZXhwb3J0IGxldCBwb3N0cztcbiAgPC9zY3JpcHQ+XG4gIFxuICA8c3ZlbHRlOmhlYWQ+XG4gICAgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIGhyZWY9XCJodHRwczovL3VzZS50eXBla2l0Lm5ldC9peG4xY2puLmNzc1wiIC8+XG4gIDwvc3ZlbHRlOmhlYWQ+XG4gIDxTdmVsdGVTZW9cbiAgZGVzY3JpcHRpb249XCJQcsOpc2VudGFpb24gZGVzIGRpZmbDqXJlbnRzIHByb2pldHMgcsOpYWxpc8OpcyBwYXIgbGUgY29sbGVjdGlmIEJsYXN0YXJ0LCBjb21tZSBsJ2V4cG9zaXRpb25zIHVuaXF1ZSBsZVxuICB0ZXJtaW5hbCwgbGUgZGlub3NhdXJlIEd1c3RhdmUgZGUgUm9tYWluIExhcmRhbmNoZXQgZXQgbGEgZnJlc3F1ZSBtb251bWVudGFsZSBHb3JpbGxhIHVyYmFpbmUgcsOpYWxpc8OpIHBhciBLYWxvdWYuIENlcyBcbiAgdHJhdmF1eCBzb250IHJlbmR1cyBhdSB0cmF2ZXJzIGRlcyBwaG90b3MgZGUgRmFiZUNvbGxhZ2UgZXQgZGVzIHZpZMOpb3MgZGUgSmVhbi1QaWVycmUoc3RhZmZ2aWTDqW8pXCJcbiAgdGl0bGU9XCJQcm9qZXRzIHLDqWFsaXPDqXMgcGFyIGxlIGNvbGxlY3RpZiBCbGFzdGFydC4gRnJlc3F1ZXMsIGdyYXBoZXMgc2N1bHB0dXJlcyBsZXMgYXJ0aXN0ZXMgcmVsw6h2ZW50IHRvdXMgbGVzIGTDqWZpc1wiXG4gIG9wZW5HcmFwaD17e1xuICB0eXBlOiBcImFydGljbGVcIixcbiAgdGl0bGU6IFwiUHJvamV0cyByw6lhbGlzw6lzIHBhciBsZSBjb2xsZWN0aWYgQmxhc3RhcnRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJQcsOpc2VudGFpb24gZGVzIGRpZmbDqXJlbnRzIHByb2pldHMgcsOpYWxpc8OpcyBwYXIgbGUgY29sbGVjdGlmIEJsYXN0YXJ0LCBjb21tZSBsJ2V4cG9zaXRpb25zIHVuaXF1ZSBsZSB0ZXJtaW5hbC4gXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vYmxhc3QtYXJ0LmFydC9ibGFzdFwiLFxuICAgIGltYWdlczogW1xuICAgICAge1xuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9ibGFzdC1hcnQuYXJ0L2xvZ28tNTEyLnBuZ1wiLFxuICAgICAgICB3aWR0aDogNzU5LFxuICAgICAgICBoZWlnaHQ6IDU4NSxcbiAgICAgICAgYWx0OiBcIkxvZ28gQmxhc3QgYXJ0XCIsXG4gICAgICB9LFxuICAgIF0sXG4gIH19XG4vPlxuICB7I2lmIHBvc3RzfVxuICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICB7I2VhY2ggcG9zdHMgYXMgcG9zdCwgaX1cbiAgICA8ZGl2IGNsYXNzPXtpICUgMiA9PSAwID8gXCJpbXBhaXJcIiA6IFwicGFpclwifT5cbiAgICAgIDxhcnRpY2xlPlxuICAgICAgICA8aDI+e3Bvc3Qubm9tfTwvaDI+XG4gICAgICAgIDxwPlxuICAgICAgICAgIHtwb3N0LmRlc2NyaXB0aW9ufVxuICAgICAgICA8L3A+XG4gICAgICA8L2FydGljbGU+XG4gICAgICA8YXNpZGU+XG4gICAgICAgIDxpbWdcbiAgICAgICAgICBzcmM9e3VybHBBcGkgKyBwb3N0LnByb2ZpbGltYWdlLnVybH1cbiAgICAgICAgICBhbHQ9e1wicG9ydHJhaXQgZGUgXCIgKyBwb3N0Lm5vbX1cbiAgICAgICAgLz5cbiAgICAgIDwvYXNpZGU+XG4gICAgPC9kaXY+XG4gIHsvZWFjaH1cbiAgPC9kaXY+XG4gIHs6ZWxzZX1cbiAgPGRpdiBjbGFzcz1cInRlc3RcIj5GVUNLPC9kaXY+XG57L2lmfVxuICA8c3R5bGU+XG4gICAgLmNvbnRlbnR7XG4gICAgICAgIGZvbnQtZmFtaWx5OiBpbnRlcnN0YXRlIDtcbiAgICAgICAgcGFkZGluZzogNjBweCAwIDA7IFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXG4gICAgfVxuICAgIGRpdiB7XG4gICAgICBtYXJnaW46IDVweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBmb250LWZhbWlseTogSW50ZXJzdGF0ZTtcbiAgICB9XG4gICAgaDJ7XG4gICAgICBmb250LXdlaWdodDogbGlnaHRlcjtcbiAgICAgIGNvbG9yOiAjM2IzYjM4O1xuICAgIH1cbiAgICBhcnRpY2xlIGgyIHtcbiAgICAgIG1heC13aWR0aDogMjJyZW07XG4gICAgICBwYWRkaW5nLWxlZnQ6IDEwcmVtO1xuICAgICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICNlZjExYTE7XG4gICAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICB9XG4gICAgXG4gICAgYXNpZGUge1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIG1hcmdpbjogNXB4O1xuICAgIH1cbiAgICBpbWcge1xuICAgICAgbWF4LXdpZHRoOiAxMHJlbTtcbiAgICB9XG4gICAgLnBhaXJ7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1kaXJlY3Rpb246IHJvdy1yZXZlcnNlO1xuICAgIH1cbiAgICAucGFpciBoMiB7XG4gICAgICBwYWRkaW5nLWxlZnQ6IDA7XG4gICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xuICAgICAgbWFyZ2luLWxlZnQ6IDY2JTtcbiAgICAgIG1heC13aWR0aDo0MHJlbTtcbiAgICB9XG4gICAgQG1lZGlhKG1heC13aWR0aDo2NjBweCl7XG4gICAgICAuY29udGVudHtcbiAgICAgICAgIHBhZGRpbmctdG9wOjQwcHg7XG4gICAgICB9XG4gICAgICBkaXYge1xuICAgICAgbWFyZ2luOiAwcHg7XG4gICAgICB9XG4gICAgICBpbWd7XG4gICAgICAgIGRpc3BsYXk6bm9uZTtcbiAgICAgIH1cbiAgICAgIC5wYWlyIGgyIHtcbiAgICAgIG1hcmdpbi1sZWZ0OiAwO1xuICAgIH1cbiAgICBhcnRpY2xlIGgyIHtcbiAgICAgIHBhZGRpbmctbGVmdDogMHJlbTtcbiAgICB9XG4gICAgcHtcbiAgICAgIG1hcmdpbi1sZWZ0OjIwcHg7XG4gICAgfVxuICB9XG4gIDwvc3R5bGU+XG4gICJdLCJuYW1lcyI6WyJBcG9sbG9DbGllbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRCQTBEUyxHQUFLOzs7O2dDQUFWLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQUFDLEdBQUs7Ozs7K0JBQVYsTUFBSTs7Ozs7Ozs7Ozs7Ozs7OztvQ0FBSixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQUdLLEdBQUksSUFBQyxHQUFHOzs7O3lCQUVWLEdBQUksSUFBQyxXQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29DQUtaLE9BQU8sWUFBRyxHQUFJLElBQUMsV0FBVyxDQUFDLEdBQUc7d0NBQzlCLGNBQWMsWUFBRyxHQUFJLElBQUMsR0FBRzs7Ozs7b0RBVnhCLEdBQUMsTUFBRyxDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsR0FBRyxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7OztnRUFFakMsR0FBSSxJQUFDLEdBQUc7Z0VBRVYsR0FBSSxJQUFDLFdBQVc7OzJEQUtaLE9BQU8sWUFBRyxHQUFJLElBQUMsV0FBVyxDQUFDLEdBQUc7Ozs7aUVBQzlCLGNBQWMsWUFBRyxHQUFJLElBQUMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBM0J0QyxJQUFJLEVBQUUsU0FBUztLQUNmLEtBQUssRUFBRSw0Q0FBNEM7S0FDakQsV0FBVyxFQUFFLGlIQUFpSDtLQUM5SCxHQUFHLEVBQUUsNkJBQTZCO0tBQ2xDLE1BQU07O09BRUYsR0FBRyxFQUFFLG9DQUFvQztPQUN6QyxLQUFLLEVBQUUsR0FBRztPQUNWLE1BQU0sRUFBRSxHQUFHO09BQ1gsR0FBRyxFQUFFLGdCQUFnQjs7Ozs7Ozs7O2dCQUt0QixHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BckRGLFdBQVcsR0FBRyxHQUFHOzs7Ozs7Ozs7Ozs7O2VBWUQsT0FBTyxHQUFHLE1BQU0sRUFBRSxLQUFLO09BQ3JDLE1BQU0sT0FBT0EsYUFBWTtHQUM3QixHQUFHLEVBQUUsbUNBQW1DO0dBQ3hDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSzs7O09BR2IsT0FBTyxTQUFTLE1BQU0sQ0FBQyxLQUFLLEdBQ2hDLEtBQUssRUFBRSxXQUFXO1VBRVgsS0FBSyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVTs7O0lBRXJDLE9BQU8sR0FBRyx1QkFBdUI7Ozs7O09BSTFCLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
