import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_each_argument, a as validate_slots, c as create_component, b as claim_component, m as mount_component, t as transition_in, e as transition_out, f as destroy_component, g as element, h as space, j as text, k as claim_element, l as children, n as detach_dev, o as claim_space, p as claim_text, q as attr_dev, r as add_location, u as insert_dev, w as append_dev, x as listen_dev, y as group_outros, z as check_outros, A as destroy_each, B as run_all, C as query_selector_all, D as noop } from './client.cbb8e25b.js';
import Slide from 'Slide.svelte';
import { g as gql, D as DefaultClient } from './bundle.esm.ce987c6b.js';

/* src/components/home.svelte generated by Svelte v3.35.0 */
const file = "src/components/home.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (56:0) {#each presentation as post}
function create_each_block(ctx) {
	let slide;
	let current;

	slide = new Slide({
			props: {
				imageUrl: urlpApi + /*post*/ ctx[4].cover.url,
				alternText: /*post*/ ctx[4].titre,
				slideNo: /*imageShowIndex*/ ctx[1],
				totalSlide: /*presentation*/ ctx[0].length,
				imageShowing: /*post*/ ctx[4].idP * -1 + /*presentation*/ ctx[0].length + 1 === /*imageShowIndex*/ ctx[1],
				infos: /*post*/ ctx[4].titre,
				slug: urlSlug + /*post*/ ctx[4].Slug
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(slide.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(slide.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(slide, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const slide_changes = {};
			if (dirty & /*presentation*/ 1) slide_changes.imageUrl = urlpApi + /*post*/ ctx[4].cover.url;
			if (dirty & /*presentation*/ 1) slide_changes.alternText = /*post*/ ctx[4].titre;
			if (dirty & /*imageShowIndex*/ 2) slide_changes.slideNo = /*imageShowIndex*/ ctx[1];
			if (dirty & /*presentation*/ 1) slide_changes.totalSlide = /*presentation*/ ctx[0].length;
			if (dirty & /*presentation, imageShowIndex*/ 3) slide_changes.imageShowing = /*post*/ ctx[4].idP * -1 + /*presentation*/ ctx[0].length + 1 === /*imageShowIndex*/ ctx[1];
			if (dirty & /*presentation*/ 1) slide_changes.infos = /*post*/ ctx[4].titre;
			if (dirty & /*presentation*/ 1) slide_changes.slug = urlSlug + /*post*/ ctx[4].Slug;
			slide.$set(slide_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(slide.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(slide.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(slide, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(56:0) {#each presentation as post}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div1;
	let div0;
	let t0;
	let a0;
	let t1;
	let t2;
	let a1;
	let t3;
	let current;
	let mounted;
	let dispose;
	let each_value = /*presentation*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			a0 = element("a");
			t1 = text("❮");
			t2 = space();
			a1 = element("a");
			t3 = text("❯");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div1_nodes);
			a0 = claim_element(div1_nodes, "A", { href: true, class: true });
			var a0_nodes = children(a0);
			t1 = claim_text(a0_nodes, "❮");
			a0_nodes.forEach(detach_dev);
			t2 = claim_space(div1_nodes);
			a1 = claim_element(div1_nodes, "A", { href: true, class: true });
			var a1_nodes = children(a1);
			t3 = claim_text(a1_nodes, "❯");
			a1_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "container svelte-1mpw5tt");
			add_location(div0, file, 54, 0, 1071);
			attr_dev(a0, "href", "#arrowL");
			attr_dev(a0, "class", "prev svelte-1mpw5tt");
			add_location(a0, file, 67, 0, 1497);
			attr_dev(a1, "href", "#arrowR");
			attr_dev(a1, "class", "next svelte-1mpw5tt");
			add_location(a1, file, 68, 0, 1562);
			add_location(div1, file, 53, 0, 1065);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			append_dev(div1, t0);
			append_dev(div1, a0);
			append_dev(a0, t1);
			append_dev(div1, t2);
			append_dev(div1, a1);
			append_dev(a1, t3);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(a0, "click", /*prevSlide*/ ctx[2], false, false, false),
					listen_dev(a1, "click", /*nextSlide*/ ctx[3], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*urlpApi, presentation, imageShowIndex, urlSlug*/ 3) {
				each_value = /*presentation*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div0, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const imageQuery = gql`
   query cover{
     projets(sort:"date:desc"){
       id
       idP
       titre
       cover {
         url
       }
       Slug
     }
   }
 `;

async function preload() {
	const client = new DefaultClient({
			uri: "https://grldfaure.xyz/graphql",
			fetch: this.fetch
		});

	const results = await client.query({ query: imageQuery });
	return { presentation: results.data.projets };
}

const urlpApi = "https://grldfaure.xyz";
const urlSlug = "projet/";

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Home", slots, []);
	let { presentation } = $$props;

	// slideshow change image	
	let imageShowIndex = 1;

	const prevSlide = () => {
		if (imageShowIndex === 1) {
			$$invalidate(1, imageShowIndex = presentation.length);
		} else {
			$$invalidate(1, imageShowIndex -= 1);
		}
	};

	const nextSlide = () => {
		if (imageShowIndex === presentation.length) {
			$$invalidate(1, imageShowIndex = 1);
		} else {
			$$invalidate(1, imageShowIndex += 1);
		}
	};

	const writable_props = ["presentation"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Home> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("presentation" in $$props) $$invalidate(0, presentation = $$props.presentation);
	};

	$$self.$capture_state = () => ({
		ApolloClient: DefaultClient,
		gql,
		Slide,
		imageQuery,
		preload,
		urlpApi,
		urlSlug,
		presentation,
		imageShowIndex,
		prevSlide,
		nextSlide
	});

	$$self.$inject_state = $$props => {
		if ("presentation" in $$props) $$invalidate(0, presentation = $$props.presentation);
		if ("imageShowIndex" in $$props) $$invalidate(1, imageShowIndex = $$props.imageShowIndex);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [presentation, imageShowIndex, prevSlide, nextSlide];
}

class Home extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { presentation: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Home",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*presentation*/ ctx[0] === undefined && !("presentation" in props)) {
			console.warn("<Home> was created without expected prop 'presentation'");
		}
	}

	get presentation() {
		throw new Error("<Home>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set presentation(value) {
		throw new Error("<Home>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/index.svelte generated by Svelte v3.35.0 */

function create_fragment(ctx) {
	let t;
	let home;
	let current;
	home = new Home({ $$inline: true });

	const block = {
		c: function create() {
			t = space();
			create_component(home.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1db4f4l\"]", document.head);
			head_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			claim_component(home.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			document.title = "Blast ART";
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
			mount_component(home, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(home.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(home.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			destroy_component(home, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Routes", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Routes> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ Home });
	return [];
}

class Routes extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Routes",
			options,
			id: create_fragment.name
		});
	}
}

export default Routes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguOGM1YjBjZTAuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2hvbWUuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPlxuICAgIGltcG9ydCBBcG9sbG9DbGllbnQsIHsgZ3FsIH0gZnJvbSBcImFwb2xsby1ib29zdFwiO1xuICAgIGltcG9ydCBTbGlkZSBmcm9tIFwiU2xpZGUuc3ZlbHRlXCI7XG4gY29uc3QgaW1hZ2VRdWVyeSA9IGdxbGBcbiAgIHF1ZXJ5IGNvdmVye1xuICAgICBwcm9qZXRzKHNvcnQ6XCJkYXRlOmRlc2NcIil7XG4gICAgICAgaWRcbiAgICAgICBpZFBcbiAgICAgICB0aXRyZVxuICAgICAgIGNvdmVyIHtcbiAgICAgICAgIHVybFxuICAgICAgIH1cbiAgICAgICBTbHVnXG4gICAgIH1cbiAgIH1cbiBgO1xuIGV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgY29uc3QgY2xpZW50ID0gbmV3IEFwb2xsb0NsaWVudCh7XG4gICAgIHVyaTogXCJodHRwczovL2dybGRmYXVyZS54eXovZ3JhcGhxbFwiLFxuICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgfSk7XG4gICBjb25zdCByZXN1bHRzID0gYXdhaXQgY2xpZW50LnF1ZXJ5KHtcbiAgICAgcXVlcnk6IGltYWdlUXVlcnksXG4gICB9KTtcbiAgIHJldHVybiB7IHByZXNlbnRhdGlvbjogcmVzdWx0cy5kYXRhLnByb2pldHMgfTtcbn1cblxuIGNvbnN0IHVybHBBcGkgPSBcImh0dHBzOi8vZ3JsZGZhdXJlLnh5elwiO1xuIGNvbnN0IHVybFNsdWcgPSBcInByb2pldC9cIjtcbiAgIFxuPC9zY3JpcHQ+XG5cbjxzY3JpcHQ+XG4gICBleHBvcnQgbGV0IHByZXNlbnRhdGlvbjtcbi8vIHNsaWRlc2hvdyBjaGFuZ2UgaW1hZ2VcdFxubGV0IGltYWdlU2hvd0luZGV4ID0gMTtcbiBjb25zdCBwcmV2U2xpZGUgPSAoKSA9PiB7XG4gICAgIGlmKGltYWdlU2hvd0luZGV4ID09PSAxICl7XG4gICAgICAgIGltYWdlU2hvd0luZGV4ID0gcHJlc2VudGF0aW9uLmxlbmd0aDtcbiAgICAgfWVsc2V7XG4gICAgICAgaW1hZ2VTaG93SW5kZXggLT0gMTtcbiAgICAgfVxuICAgfTtcbiBcbiBjb25zdCBuZXh0U2xpZGUgPSAoKSA9PiB7XG4gICAgIGlmIChpbWFnZVNob3dJbmRleCA9PT0gcHJlc2VudGF0aW9uLmxlbmd0aCl7XG4gICAgICAgICBpbWFnZVNob3dJbmRleCA9IDFcbiAgICAgfWVsc2V7XG4gICAgICAgaW1hZ2VTaG93SW5kZXggKz0gMTtcbiAgICAgfVxuICAgfSA7XG5cbjwvc2NyaXB0PlxuPGRpdj5cbjxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbnsjZWFjaCBwcmVzZW50YXRpb24gYXMgcG9zdH1cbiA8U2xpZGUgaW1hZ2VVcmw9e3VybHBBcGkgKyBwb3N0LmNvdmVyLnVybH0gXG4gICAgICAgICAgYWx0ZXJuVGV4dD17cG9zdC50aXRyZX0gXG4gICAgICAgICAgc2xpZGVObz17aW1hZ2VTaG93SW5kZXh9XG4gICAgICAgICAgdG90YWxTbGlkZT17cHJlc2VudGF0aW9uLmxlbmd0aH1cbiAgICAgICAgICBpbWFnZVNob3dpbmc9eyhwb3N0LmlkUCAqIC0xKSArIHByZXNlbnRhdGlvbi5sZW5ndGggKyAxID09PSBpbWFnZVNob3dJbmRleH1cbiAgICAgICAgICBpbmZvcz17cG9zdC50aXRyZX1cbiAgICAgICAgICBzbHVnPXt1cmxTbHVnICsgcG9zdC5TbHVnfVxuICAgICAgICAgIC8+XG57L2VhY2h9XG48L2Rpdj5cbjwhLS0gTmV4dCBhbmQgcHJldmlvdXMgYnV0dG9ucyAtLT5cbjxhIGhyZWY9XCIjYXJyb3dMXCIgY2xhc3M9XCJwcmV2XCIgb246Y2xpY2s9e3ByZXZTbGlkZX0+JiMxMDA5NDs8L2E+XG48YSBocmVmPVwiI2Fycm93UlwiIGNsYXNzPVwibmV4dFwiIG9uOmNsaWNrPXtuZXh0U2xpZGV9PiYjMTAwOTU7PC9hPlxuPC9kaXY+XG5cbjxzdHlsZT5cbi5jb250YWluZXIge1xuIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cblxuXG4vKiBOZXh0ICYgcHJldmlvdXMgYnV0dG9ucyAqL1xuLnByZXYsXG4ubmV4dCB7XG4gY3Vyc29yOiBwb2ludGVyO1xuIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiB0b3A6IDQwJTtcbiB3aWR0aDogYXV0bztcbiBwYWRkaW5nOiAyMHB4O1xuIG1hcmdpbi1sZWZ0OiAyMHB4O1xuIGNvbG9yOiByZ2IoMjI4LCA0NiwgMjQ1KTtcbiBmb250LXdlaWdodDogYm9sZDtcbiBmb250LXNpemU6IDI1cHg7XG4gYm9yZGVyLXJhZGl1czogMCAzcHggM3B4IDA7XG4gdXNlci1zZWxlY3Q6IG5vbmU7XG4gLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbn0gXG5cbi8qIFBvc2l0aW9uIHRoZSBcIm5leHQgYnV0dG9uXCIgdG8gdGhlIHJpZ2h0ICovXG4ubmV4dCB7XG4gcmlnaHQ6IDA7XG4gbWFyZ2luLXJpZ2h0OiAyMHB4O1xuIGJvcmRlci1yYWRpdXM6IDNweCAwIDAgM3B4O1xufSBcblxuLyogT24gaG92ZXIsIGFkZCBhIGJsYWNrIGJhY2tncm91bmQgY29sb3Igd2l0aCBhIGxpdHRsZSBiaXQgc2VlLXRocm91Z2ggKi9cbi5wcmV2OmhvdmVyLFxuLm5leHQ6aG92ZXIge1xuICAgZm9udC1zaXplOiAzMHB4O1xufSBcbkBtZWRpYShtYXgtd2lkdGg6NjYwcHgpe1xuICAgIC5wcmV2e1xuICAgICAgICBtYXJnaW4tbGVmdDowcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6cmdiYSgwLCAwLCAwLCAwLjI2Nyk7XG4gICAgfVxuICAgIC5uZXh0e1xuICAgICAgICBtYXJnaW4tcmlnaHQ6MHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwgMCwgMCwgMC4yNjcpO1xuICAgIH1cbn1cbjwvc3R5bGU+Il0sIm5hbWVzIjpbIkFwb2xsb0NsaWVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Y0F3RGtCLE9BQU8sWUFBRyxHQUFJLElBQUMsS0FBSyxDQUFDLEdBQUc7eUJBQ3BCLEdBQUksSUFBQyxLQUFLO2dDQUNiLEdBQWM7aUNBQ1gsR0FBWSxJQUFDLE1BQU07MkJBQ2hCLEdBQUksSUFBQyxHQUFHLElBQUksQ0FBQyxvQkFBSSxHQUFZLElBQUMsTUFBTSxHQUFHLENBQUMsd0JBQUssR0FBYztvQkFDbkUsR0FBSSxJQUFDLEtBQUs7VUFDWCxPQUFPLFlBQUcsR0FBSSxJQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0REFOakIsT0FBTyxZQUFHLEdBQUksSUFBQyxLQUFLLENBQUMsR0FBRzt1RUFDcEIsR0FBSSxJQUFDLEtBQUs7Z0ZBQ2IsR0FBYzsrRUFDWCxHQUFZLElBQUMsTUFBTTt5RkFDaEIsR0FBSSxJQUFDLEdBQUcsSUFBSSxDQUFDLG9CQUFJLEdBQVksSUFBQyxNQUFNLEdBQUcsQ0FBQyx3QkFBSyxHQUFjO2tFQUNuRSxHQUFJLElBQUMsS0FBSzt3REFDWCxPQUFPLFlBQUcsR0FBSSxJQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUNBUDVCLEdBQVk7Ozs7Z0NBQWpCLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQ0FZbUMsR0FBUzsyQ0FDVCxHQUFTOzs7Ozs7OztrQ0FiM0MsR0FBWTs7OzsrQkFBakIsTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFBSixNQUFJOzs7Ozs7Ozs7O2tDQUFKLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFwREMsVUFBVSxHQUFHLEdBQUc7Ozs7Ozs7Ozs7Ozs7O2VBYUEsT0FBTztPQUNyQixNQUFNLE9BQU9BLGFBQVk7R0FDN0IsR0FBRyxFQUFFLCtCQUErQjtHQUNsQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7OztPQUVmLE9BQU8sU0FBUyxNQUFNLENBQUMsS0FBSyxHQUNoQyxLQUFLLEVBQUUsVUFBVTtVQUVWLFlBQVksRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU87OztNQUd2QyxPQUFPLEdBQUcsdUJBQXVCO01BQ2pDLE9BQU8sR0FBRyxTQUFTOzs7OztPQUtaLFlBQVk7OztLQUV0QixjQUFjLEdBQUcsQ0FBQzs7T0FDZixTQUFTO01BQ1IsY0FBYyxLQUFLLENBQUM7bUJBQ3BCLGNBQWMsR0FBRyxZQUFZLENBQUMsTUFBTTs7bUJBRXJDLGNBQWMsSUFBSSxDQUFDOzs7O09BSW5CLFNBQVM7TUFDUCxjQUFjLEtBQUssWUFBWSxDQUFDLE1BQU07bUJBQ3RDLGNBQWMsR0FBRyxDQUFDOzttQkFFcEIsY0FBYyxJQUFJLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
